# Patterns for solving problems
1. **Frequency counter**
   Using objects or sets to collect values or frequency of values. This pattern is used to avoid nested loops or O(n*2) operations with **arrays** or **strings**. This comes handy when there are multiple inputs and check one value is present in other. Example: Anagrams.
   Time Complexity: O(n)

2. **Multiple pointers**
   Creating pointers with respect to index or value and move to beginning, end or middle based on a condition. Very efficient for solving problems with minimal space complexity.
   Time Complexity:
3. **Sliding window**
   This is meant for **strings** or **arrays** in which we are looking for continuous subset of values. Example: Max sub array sum
4. **Divide and conquer**
5. **Dynamic programming**
6. **Greedy algorithms**
7. **Backtracking**
